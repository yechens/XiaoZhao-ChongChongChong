* 17.ç”µè¯å·ç çš„å­—æ¯ç»„åˆ
** é¢˜ç›®
#+DOWNLOADED: file:/var/folders/73/53s3wczx1l32608prn_fdgrm0000gn/T/TemporaryItems/ï¼ˆscreencaptureuiæ­£åœ¨å­˜å‚¨æ–‡ç¨¿ï¼Œå·²å®Œæˆ54ï¼‰/æˆªå±2020-07-13 ä¸‹åˆ9.10.47.png @ 2020-07-13 21:10:50
[[file:Screen-Pictures/17.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/2020-07-13_21-10-50_%E6%88%AA%E5%B1%8F2020-07-13%20%E4%B8%8B%E5%8D%889.10.47.png]]
** æ€è·¯
+ DFSå›æº¯æ³•ï¼šdfs(i,s)ä¸­iè¡¨ç¤ºé€’å½’åˆ°ç¬¬iä¸ªæ•°å­—ï¼Œsè¡¨ç¤ºå‰i-1ä¸ªæ•°å­—å¯èƒ½ç»„åˆçš„å­—ç¬¦ä¸²ï¼Œå½“éå†åˆ°æ•°å­—ç»“å°¾æ—¶ï¼Œå°†ç»“æœæ·»åŠ åˆ°åˆ—è¡¨ä¸­
** code
 #+BEGIN_SRC python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return []
        dl = len(digits)
        phone = {'2': ['a', 'b', 'c'],
                 '3': ['d', 'e', 'f'],
                 '4': ['g', 'h', 'i'],
                 '5': ['j', 'k', 'l'],
                 '6': ['m', 'n', 'o'],
                 '7': ['p', 'q', 'r', 's'],
                 '8': ['t', 'u', 'v'],
                 '9': ['w', 'x', 'y', 'z']}
        self.ans = []
        def dfs(i, s):
            if i==len(digits):
                self.ans.append(s)
                return
            for c in phone[digits[i]]:
                s += c
                dfs(i+1, s)
		# å›æº¯
                s = s[:-1]
        dfs(0, '')
        return self.ans
 #+END_SRC
* 401.äºŒè¿›åˆ¶æ‰‹è¡¨
** é¢˜ç›®
#+DOWNLOADED: file:/var/folders/73/53s3wczx1l32608prn_fdgrm0000gn/T/TemporaryItems/ï¼ˆscreencaptureuiæ­£åœ¨å­˜å‚¨æ–‡ç¨¿ï¼Œå·²å®Œæˆ67ï¼‰/æˆªå±2020-07-15 ä¸Šåˆ12.56.18.png @ 2020-07-15 00:56:20
[[file:Screen-Pictures/401.%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8/2020-07-15_00-56-20_%E6%88%AA%E5%B1%8F2020-07-15%20%E4%B8%8A%E5%8D%8812.56.18.png]]
** æ€è·¯
[[https://leetcode-cn.com/problems/binary-watch/solution/hui-su-by-bu-hui-er-cha-shu/]]
** code
#+BEGIN_SRC python
class Solution:
    def readBinaryWatch(self, num: int) -> List[str]:
        ans = []
        times = [8,4,2,1,32,16,8,4,2,1]
        # minutes = []
        def dfs(n, hour, minute, k):
            # è·³å‡ºæ¡ä»¶
            if n==num:
                if minute < 10:
                    ans.append(str(hour)+':0'+str(minute))
                else:
                    ans.append(str(hour)+':'+str(minute))
            if k >= 4:
                for i, m in enumerate(times[k:]):
                    minute += m
                    if minute <= 59:
                        dfs(n+1, hour, minute, k+i+1)
                    minute -= m
            else:
                for i, h in enumerate(times[k:4]):
                    hour += h
                    if hour <= 11:
                        dfs(n+1, hour, minute, k+i+1)
                    # å›æº¯
                    hour -= h
                for i, m in enumerate(times[4:]):
                    minute += m
                    if minute <= 59:
                        dfs(n+1, hour, minute, 4+i+1)
                    minute -= m
        dfs(0, 0, 0, 0)
        return ans
#+END_SRC
* 39.ç»„åˆæ€»å’Œ
** é¢˜ç›®
#+DOWNLOADED: file:/var/folders/73/53s3wczx1l32608prn_fdgrm0000gn/T/TemporaryItems/ï¼ˆscreencaptureuiæ­£åœ¨å­˜å‚¨æ–‡ç¨¿ï¼Œå·²å®Œæˆ66ï¼‰/æˆªå±2020-07-15 ä¸Šåˆ12.55.09.png @ 2020-07-15 00:55:11
[[file:Screen-Pictures/39.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/2020-07-15_00-55-11_%E6%88%AA%E5%B1%8F2020-07-15%20%E4%B8%8A%E5%8D%8812.55.09.png]]
** æ€è·¯
DFSå›æº¯ï¼Œè€ƒè™‘è·¯å¾„å’Œè¶…è¿‡targetæ—¶è¿›è¡Œå‰ªæï¼Œå¹¶ä¸”é€‰æ‹©çš„æ—¶å€™ä¸ºäº†é¿å…é‡å¤ï¼Œåªé€‰å–>=å½“å‰ç´¢å¼•çš„å…ƒç´ 
** code
#+BEGIN_SRC python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        candidates.sort()
        ans = []
        def dfs(index, path):
            # è·³å‡ºæ¡ä»¶
            if sum(path)==target:
                path_ = path[:]
                ans.append(path_)
            elif sum(path)<target:
                for i, c in enumerate(candidates[index:]):
                    path.append(c)
                    # å‰ªæ
                    if sum(path)>target:
                        path.pop()
                        break
                    dfs(index+i, path)
                    path.pop()
        dfs(0, [])
        return ans
#+END_SRC
* 77.ç»„åˆ
** é¢˜ç›®
#+DOWNLOADED: file:/var/folders/73/53s3wczx1l32608prn_fdgrm0000gn/T/TemporaryItems/ï¼ˆscreencaptureuiæ­£åœ¨å­˜å‚¨æ–‡ç¨¿ï¼Œå·²å®Œæˆ61ï¼‰/æˆªå±2020-07-14 ä¸‹åˆ4.53.56.png @ 2020-07-14 16:53:58
[[file:Screen-Pictures/77.%E7%BB%84%E5%90%88/2020-07-14_16-53-58_%E6%88%AA%E5%B1%8F2020-07-14%20%E4%B8%8B%E5%8D%884.53.56.png]]
** æ€è·¯
éœ€è¦é¿å…é‡å¤ï¼Œå› æ­¤éœ€è¦ä»å½“å‰å±‚çš„ç¬¬iä¸ª+index+1ï¼Œä¸èƒ½å–è‡ªå·±
** code
#+BEGIN_SRC python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        nums = list(range(1, n+1))
        ans = []
        def dfs(n, index, path):
            if n==k:
                ans.append(path[:])
            for i, c in enumerate(nums[index:]):
                path.append(c)
                dfs(n+1, index+i+1, path)
                path.pop()
        dfs(0, 0, [])
        return ans
#+END_SRC
* 40.ç»„åˆæ€»å’ŒII
** é¢˜ç›®
#+DOWNLOADED: file:/var/folders/73/53s3wczx1l32608prn_fdgrm0000gn/T/TemporaryItems/ï¼ˆscreencaptureuiæ­£åœ¨å­˜å‚¨æ–‡ç¨¿ï¼Œå·²å®Œæˆ65ï¼‰/æˆªå±2020-07-15 ä¸Šåˆ12.53.47.png @ 2020-07-15 00:53:52
[[file:Screen-Pictures/40.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII/2020-07-15_00-53-52_%E6%88%AA%E5%B1%8F2020-07-15%20%E4%B8%8A%E5%8D%8812.53.47.png]]
** æ€è·¯
[[https://leetcode-cn.com/problems/combination-sum-ii/solution/hui-su-jian-zhi-by-bu-hui-er-cha-shu/][ğŸ˜„]]
** code
#+BEGIN_SRC python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        candidates.sort()
        ans = []
        def dfs(index, path):
            # è·³å‡ºæ¡ä»¶
            if sum(path)==target:
                ans.append(path[:])
            for i, c in enumerate(candidates[index:]):
                # å»é™¤é‡å¤çš„ç»„åˆ
                if i==0 or c!=candidates[index:][i-1]:
                    path.append(c)
                    # å‰ªæ
                    if sum(path)>target:
                        path.pop()
                        break
                    dfs(index+i+1, path)
                    path.pop()
        dfs(0, [])
        return ans
#+END_SRC
* ç»„åˆæ€»å’ŒIV
** é¢˜ç›®
#+DOWNLOADED: file:/var/folders/73/53s3wczx1l32608prn_fdgrm0000gn/T/TemporaryItems/ï¼ˆscreencaptureuiæ­£åœ¨å­˜å‚¨æ–‡ç¨¿ï¼Œå·²å®Œæˆ64ï¼‰/æˆªå±2020-07-15 ä¸Šåˆ12.52.18.png @ 2020-07-15 00:52:20
[[file:Screen-Pictures/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIV/2020-07-15_00-52-20_%E6%88%AA%E5%B1%8F2020-07-15%20%E4%B8%8A%E5%8D%8812.52.18.png]]
** æ€è·¯
dp[k]è¡¨ç¤ºç»„æˆæ•°ç›®ä¸ºkçš„ç§ç±»æœ‰å¤šå°‘ï¼ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸ºï¼šdp[k]=sum(dp[k-n] for n in nums)
** code
#+BEGIN_SRC python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        if not nums:
            return 0
        nums.sort()
        dp = [0 for i in range(target+1)]
        dp[0] = 0
        for amount in range(nums[0], target+1):
            for num in nums:
                if amount>num:
                    dp[amount] += dp[amount-num]
                elif amount==num:
                    dp[amount] += 1
        return dp[target]
#+END_SRC
